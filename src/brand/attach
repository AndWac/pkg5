#!/bin/ksh -p
#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#
#
# Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#

. /usr/lib/brand/ipkg/common.ksh

m_attach_log=$(gettext "Log File: %s")
m_zfs=$(gettext "A ZFS file system was created for the zone.")
m_attaching=$(gettext "Attaching...")
m_usage=$(gettext  "attach [-a archive] [-d dataset] [-n] [-r zfs-recv] [-u]\n\tThe -a archive option specifies a tar file or cpio archive.\n\tThe -d dataset option specifies an existing dataset.\n\tThe -r zfs-recv option receives the output of a 'zfs send' command\n\tof an existing zone root dataset.\n\tThe -u option indicates that the software should be updated to match\n\tthe current host.")
m_gzinc=$( gettext "       Global zone version: %s")
m_zinc=$(  gettext "   Non-Global zone version: %s")
m_insync=$(gettext "                Evaluation: Packages in %s are in sync with global zone.")
m_uprev=$(gettext  "                Evaluation: %s is newer than the global zone.")
m_dnrev=$(gettext  "                Evaluation: %s is downrev of the global zone.")
m_resetpub=$(gettext  "           Publisher Check: Zone preferred publisher does not contain")
m_resetpub2=$(gettext "                            %s.")
m_resetpub3=$(gettext "           Publisher Reset: Copying preferred publisher from global zone.")
m_pubfine=$(gettext   "           Publisher Check: Looks good.")
m_cache=$(gettext     "                     Cache: Using %s.")
m_updating=$(gettext  "  Updating non-global zone: Output follows")
m_sync_done=$(gettext "  Updating non-global zone: Zone updated to %s")
m_complete=$(gettext "Attach complete.")

sanity_fail_global=$(gettext  "  Sanity Check: FAILED, the image is from the global zone.")
f_downrev=$(gettext "Zone is downrev of global zone.  Specify -u to update it.")
f_uprev=$(gettext "Zone is uprev of global zone.  Global zone will need to be updated before attach can proceed.")
f_update=$(gettext "Could not update attaching zone")
f_gz_entire=$(gettext "Could not find 'entire' incorporation for global zone.")
f_zone_entire=$(gettext "Could not find 'entire' incorporation for non-global zone.")
f_fmri_compare=$(gettext "Failed to compare 'entire' FMRIs")
f_reset_pub=$(gettext "Failed to reset publisher to %s %s")
f_del_pub=$(gettext "Failed to unset publisher '%s' for zone.")
f_no_pref_publisher=$(gettext "Unable to get preferred publisher information for zone '%s'.")
f_get_secinfo=$(gettext "Failed to get key/cert information for publisher %s")
f_nosuch_key=$(gettext "Failed to find key %s for global zone publisher")
f_nosuch_cert=$(gettext "Failed to find cert %s for global zone publisher")

# Clean up on interrupt
trap_cleanup()
{
	msg=$(gettext "Installation cancelled due to interrupt.")
	log "$msg"

	# umount any mounted file systems
	umnt_fs

	trap_exit
}

# If the attach failed then clean up the ZFS datasets we created.
trap_exit()
{
	if [[ $EXIT_CODE == $ZONE_SUBPROC_OK ]]; then
		# unmount the zoneroot if labeled brand
		is_brand_labeled
		(( $? == 1 )) && ( umount $ZONEROOT || \
		    printf "$f_zfs_unmount" "$ZONEPATH/root" )
	else
		if [[ "$install_media" != "-" ]]; then
			/usr/lib/brand/ipkg/uninstall $ZONENAME $ZONEPATH -F
		else
			# Restore the zone properties for the pre-existing
			# dataset.
			if [[ -n "$ACTIVE_DS" ]]; then
				zfs set zoned=off $ACTIVE_DS >/dev/null 2>&1
				zfs set canmount=on $ACTIVE_DS >/dev/null 2>&1
				zfs set mountpoint=$ZONEROOT $ACTIVE_DS \
				    >/dev/null 2>&1
			fi
		fi
	fi

	exit $EXIT_CODE
}

EXIT_CODE=$ZONE_SUBPROC_USAGE
install_media="-"

trap trap_cleanup INT
trap trap_exit EXIT

#set -o xtrace

PKG="/usr/bin/pkg"
KEYDIR=/var/pkg/ssl

# If we weren't passed at least two arguments, exit now.
(( $# < 2 )) && exit $ZONE_SUBPROC_USAGE

ZONENAME="$1"
ZONEPATH="$2"
# XXX shared/common script currently uses lower case zonename & zonepath
zonename="$ZONENAME"
zonepath="$ZONEPATH"

shift; shift	# remove ZONENAME and ZONEPATH from arguments array

ZONEROOT="$ZONEPATH/root"
logdir="$ZONEROOT/var/log"

#
# Resetting GZ_IMAGE to something besides slash allows for simplified
# debugging of various global zone image configurations-- simply make
# an image somewhere with the appropriate interesting parameters.
#
GZ_IMAGE=${GZ_IMAGE:-/}
PKG_IMAGE=$GZ_IMAGE
export PKG_IMAGE

noexecute=0

unset inst_type

# Other brand attach options are invalid for this brand.
while getopts "a:d:nr:u" opt; do
	case $opt in
		a)
			if [[ -n "$inst_type" ]]; then
				fatal "$incompat_options" "$m_usage"
			fi
		 	inst_type="archive"
			install_media="$OPTARG"
			;;
		d)
			if [[ -n "$inst_type" ]]; then
				fatal "$incompat_options" "$m_usage"
			fi
		 	inst_type="directory"
			install_media="$OPTARG"
			;;
		n)	noexecute=1 ;;
		r)
			if [[ -n "$inst_type" ]]; then
				fatal "$incompat_options" "$m_usage"
			fi
		 	inst_type="stdin"
			install_media="$OPTARG"
			;;
		u)	allow_update=1 ;;
		?)	fail_usage "" ;;
		*)	fail_usage "";;
	esac
done
shift $((OPTIND-1))

if [[ $noexecute == 1 && -n "$inst_type" ]]; then
	fatal "$m_usage"
fi

[[ -z "$inst_type" ]] && inst_type="directory"

if [ $noexecute -eq 1 ]; then
	#
	# The zone doesn't have to exist when the -n option is used, so do
	# this work early.
	#

	# XXX There is no sw validation for IPS right now, so just pretend
	# everything will be ok.
	EXIT_CODE=$ZONE_SUBPROC_OK
	exit $ZONE_SUBPROC_OK
fi

LOGFILE=$(/usr/bin/mktemp -t -p /var/tmp $ZONENAME.attach_log.XXXXXX)
if [[ -z "$LOGFILE" ]]; then
	fatal "$e_tmpfile"
fi
exec 2>>"$LOGFILE"
log "$m_attach_log" "$LOGFILE"

#
# TODO - once sxce is gone, move the following block into
# usr/lib/brand/shared/common.ksh code to share with other brands using
# the same zfs dataset logic for attach. This currently uses get_current_gzbe
# so we can't move it yet since beadm isn't in sxce.
#

# Validate that the zonepath is not in the root dataset.
pdir=`dirname $ZONEPATH`
get_zonepath_ds $pdir
fail_zonepath_in_rootds $ZONEPATH_DS

EXIT_CODE=$ZONE_SUBPROC_NOTCOMPLETE

if [[ "$install_media" == "-" ]]; then
	#
	# Since we're using a pre-existing dataset, the dataset currently
	# mounted on the {zonepath}/root becomes the active dataset.  We
	# can't depend on the usual dataset attributes to detect this since
	# the dataset could be a detached zone or one that the user set up by
	# hand and lacking the proper attributes.  However, since the zone is
	# not attached yet, the 'install_media == -' means the dataset must be
	# mounted at this point.
	#
	ACTIVE_DS=`mount -p | nawk -v zroot=$ZONEROOT '{
	    if ($3 == zroot && $4 == "zfs")
		print $1
	    }'`

	[[ -z "$ACTIVE_DS" ]] && fatal "$f_no_active_ds"

	# Set up proper attributes on the ROOT dataset.
	get_zonepath_ds $ZONEPATH
	zfs list -H -t filesystem -o name $ZONEPATH_DS/ROOT >/dev/null 2>&1
	(( $? != 0 )) && fatal "$f_no_active_ds"

	zfs set mountpoint=legacy $ZONEPATH_DS/ROOT >/dev/null 2>&1
	zfs set zoned=on $ZONEPATH_DS/ROOT >/dev/null 2>&1

	#
	# We're typically using a pre-existing mounted dataset so setting the
	# following propery changes will cause the {zonepath}/root dataset to
	# be unmounted.  However, a p2v with an update-on-attach will have
	# created the dataset with the correct properties, so setting these
	# attributes won't unmount the dataset.  Thus, we check the mount
	# and attempt the remount if necessary.
	#
	get_current_gzbe
	zfs set $PROP_PARENT=$CURRENT_GZBE $ACTIVE_DS >/dev/null 2>&1
	zfs set $PROP_ACTIVE=on $ACTIVE_DS >/dev/null 2>&1
	zfs set canmount=noauto $ACTIVE_DS >/dev/null 2>&1
	zfs inherit mountpoint $ACTIVE_DS >/dev/null 2>&1
	zfs inherit zoned $ACTIVE_DS >/dev/null 2>&1

	mounted_ds=`mount -p | nawk -v zroot=$ZONEROOT '{
	    if ($3 == zroot && $4 == "zfs")
		print $1
	    }'`

	if [[ -z $mounted_ds ]]; then
		mount -F zfs $ACTIVE_DS $ZONEROOT || fatal "$f_zfs_mount"
	fi
else
	#
	# Since we're not using a pre-existing ZFS dataset layout, create
	# the zone datasets and mount them.  Start by creating the zonepath
	# dataset, similar to what zoneadm would do for an initial install.
	#
	zds=$(zfs list -H -t filesystem -o name $pdir 2>/dev/null)
	if (( $? == 0 )); then
		pnm=$(/usr/bin/basename $ZONEPATH)
		# The zonepath dataset might already exist.
		zfs list -H -t filesystem -o name $zds/$pnm >/dev/null 2>&1
		if (( $? != 0 )); then
			zfs create "$zds/$pnm"
			(( $? != 0 )) && fatal "$f_zfs_create"
			vlog "$m_zfs"
		fi
	fi

	create_active_ds
fi

#
# The zone's datasets are now in place.
#

log "$m_attaching"
install_image "$inst_type" "$install_media"

#
# End of TODO block to move to common code.
#

#
# Perform a final sanity check to confirm the image is not of the global zone.
# Check for a few well-known global zone only svcs.
#
[[ -f $ZONEROOT/var/svc/manifest/system/sysevent.xml ]] && \
    fatal "$sanity_fail_global"
[[ -f $ZONEROOT/var/svc/manifest/system/zones.xml ]] && \
    fatal "$sanity_fail_global"
[[ -f $ZONEROOT/var/svc/manifest/system/dumpadm.xml ]] && \
    fatal "$sanity_fail_global"

#
# Look for the 'entire' incorporation's FMRI in the current image; due to users
# doing weird machinations with their publishers, we strip off the publisher
# from the FMRI if it is present.
#
gz_entire_fmri=$(get_entire_incorp) || fatal "$f_gz_entire"

#
# Get publisher information for global zone.
# If we were not able to get the zone's preferred publisher, complain.
#

get_publisher_urls preferred origin |
    IFS="=" read gz_publisher gz_publisher_origins

[[ -z $gz_publisher ]] && fail_usage "$f_no_pref_publisher" "global"
[[ -z $gz_publisher_origins ]] && fail_usage "$f_no_pref_publisher" "global"

get_publisher_urls preferred mirror |
    IFS="=" read ignored gz_publisher_mirrors

get_pub_secinfo $gz_publisher | read gzkeyfile gzcertfile
if [[ $? -ne 0 ]]; then
	fail_usage "$f_get_secinfo" $gz_publisher
fi
[[ $gzkeyfile != "None" && ! -f $gzkeyfile ]] && \
    fail_usage "$f_nosuch_key" $gzkeyfile
[[ $gzcertfile != "None" && ! -f $gzcertfile ]] && \
    fail_usage "$f_nosuch_cert" $gzcertfile


#
# We're done with the global zone: switch images to the non-global
# zone.
#
PKG_IMAGE="$ZONEROOT"

#
# Get publisher information for non global zone.
# If we were not able to get the zone's preferred publisher, complain.
#
get_publisher_urls preferred origin |
    IFS="=" read zone_publisher zone_publisher_origins

[[ -z $zone_publisher ]] && fail_usage "$f_no_pref_publisher" $ZONENAME
[[ -z $zone_publisher_origins ]] && fail_usage "$f_no_pref_publisher" $ZONENAME

get_publisher_urls preferred mirror |
    IFS="=" read ignored zone_publisher_mirrors

#
# Get entire incorp for non-global zone
#
zone_entire_fmri=$(get_entire_incorp) || fatal "$f_zone_entire"

printf "$m_gzinc\n" $gz_entire_fmri
printf "$m_zinc\n" $zone_entire_fmri
# 
# if the zone entire and the gz entire match, we're good.
#
comp=$(/usr/lib/brand/ipkg/fmri_compare $zone_entire_fmri $gz_entire_fmri)
if [[ $? -ne 0 ]]; then
	fatal "$f_fmri_compare"
fi
if [[ $comp = "=" ]]; then
	printf "$m_insync\n" $ZONENAME
	echo $m_complete
	EXIT_CODE=$ZONE_SUBPROC_OK
	exit $ZONE_SUBPROC_OK
fi
if [[ $comp = ">" ]]; then
	printf "$m_uprev\n" $ZONENAME
	fatal "$f_uprev"
fi

#
# If we're here, the zone is downrev of the global zone
#
if [ -z $allow_update ]; then
	# zone is downrev
	printf "$m_dnrev\n" $ZONENAME
	fatal "$f_downrev"
fi

#
# See if the zone knows about the gz entire fmri in question.  If yes,
# we'll try using that.
#
LC_ALL=C $PKG list --no-refresh -a $gz_entire_fmri > /dev/null 2>&1

#
# If this doesn't exist, then we reset the preferred pub for
# the zone to that of the global zone on attach, and try again.
#
if [[ $? -ne 0 ]]; then
	printf "$m_resetpub\n"
	printf "$m_resetpub2\n" $gz_entire_fmri
	printf "$m_resetpub3\n"

	safe_dir var
	safe_dir var/pkg

	# Copy credentials from global zone.
	secinfo=""
	if [[ $gzkeyfile != "None" || $gzcertfile != "None" ]]; then
		if [[ -e $ZONEROOT/$KEYDIR ]]; then
			safe_dir $KEYDIR
		else
			mkdir -m 755 $ZONEROOT/$KEYDIR
		fi
	fi

	if [[ $gzkeyfile != None ]]; then
		newlocation="$KEYDIR/attach_$(basename $gzkeyfile)"
		safe_copy $gzkeyfile $ZONEROOT/$newlocation
		chmod 644 $ZONEROOT/$newkeylocation
		chown -h root:root $ZONEROOT/$newkeylocation
		secinfo="$secinfo -k $newlocation"
	fi
	if [[ $gzcertfile != None ]]; then
		newlocation="$KEYDIR/attach_$(basename $gzcertfile)"
		safe_copy $gzcertfile $ZONEROOT/$newlocation
		chmod 644 $ZONEROOT/$newkeylocation
		chown -h root:root $ZONEROOT/$newkeylocation
		secinfo="$secinfo -c $newlocation"
	fi

	# Note that we do cause a refresh here--at some point we need the
	# catalog to be updated.

	# Be certain that the global zone preferred publisher exists in
	# the non-global zone.  If it doesn't, all of these comparisons
	# are not valid.
	del_ngz_pub=0
	if [[ -n "$zone_publisher" && "$zone_publisher" != "$gz_publisher" ]];
	then
		zone_publisher_origins=""
		zone_publisher_mirrors=""
		del_ngz_pub=1
	fi

	# Add any origins not found in zone configuration.
	origins=""
	src="$(echo $zone_publisher_origins | sed 's/ /|/g')"
	for u in $gz_publisher_origins; do
		[[ -z "$u" ]] && continue
		case $u in
			$src)   ;; # Already in zone config.
			*)      origins="${origins}-g $u ";; # Add.
		esac
	done

	# Remove any origins not found in global configuration.
	src="$(echo $gz_publisher_origins | sed 's/ /|/g')"
	for u in $zone_publisher_origins; do
		[[ -z "$u" ]] && continue
		case $u in
			$src)   ;; # In global config.
			*)      origins="${origins}-G $u ";; # Remove.
		esac
	done

	# Add any mirrors not found in zone configuration.
	mirrors=""
	src="$(echo $zone_publisher_mirrors | sed 's/ /|/g')"
	for u in $gz_publisher_mirrors; do
		case $u in
			$src)   ;; # Already in zone config.
			*)      mirrors="${mirrors}-m $u ";; # Add.
		esac
	done

	# Remove any mirrors not found in global configuration.
	src="$(echo $gz_publisher_mirrors | sed 's/ /|/g')"
	for u in $zone_publisher_mirrors; do
		case $u in
			$src)   ;; # In global config.
			*)      mirrors="${mirrors}-M $u ";; # Remove.
		esac
	done

	$PKG set-publisher -P $origins $mirrors $secinfo $gz_publisher
	if [[ $? -ne 0 ]]; then
		fatal "$f_reset_pub" $gz_publisher \
		    "$gz_publisher_origins $gz_publisher_mirrors"
	fi

	# If the original preferred non-global zone publisher has the 
	# same URI as the global zone publisher we just stuck into the zone,
	# then we now need to delete the old ngz publisher.
	(( $del_ngz_pub == 1 )) && ( $PKG unset-publisher $zone_publisher || \
	    fatal "$f_del_pub" $zone_publisher )

	zone_publisher=$gz_publisher
	zone_publisher_origins=$gz_publisher_origins
	zone_publisher_mirrors=$gz_publisher_mirrors
else
	printf "$m_pubfine\n"
fi

if [ -d /var/pkg/download ]; then
	PKG_CACHEDIR=/var/pkg/download
	export PKG_CACHEDIR
	printf "$m_cache\n" $PKG_CACHEDIR
fi

printf "$m_updating\n"

$PKG install $gz_entire_fmri || pkg_err_check "$f_update"

printf "$m_sync_done\n" $gz_entire_fmri
printf "$m_complete\n"

EXIT_CODE=$ZONE_SUBPROC_OK
exit $ZONE_SUBPROC_OK
