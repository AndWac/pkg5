#!/bin/ksh -p
#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#

#
# Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
#

. /usr/lib/brand/ipkg/common.ksh

# Allows developer to override some things like PATH and PYTHONPATH
. /usr/lib/brand/ipkg/developerenv.ksh

m_attach_log=$(gettext "Log File: %s")
m_zfs=$(gettext "A ZFS file system was created for the zone.")
m_usage=$(gettext  "attach [-a archive] [-d dataset] [-n] [-r zfs-recv] [-u] [-v] [-c profile | dir]\n\tThe -a archive option specifies a tar file or cpio archive.\n\tThe -d dataset option specifies an existing dataset.\n\tThe -r zfs-recv option receives the output of a 'zfs send' command\n\tof an existing zone root dataset.\n\tThe -u option indicates that the software should be updated to match\n\tthe current host.\n\tThe -v option enables verbose output.\n\tThe -c option gives a profile or a directory of profiles to be applied to the system after attach.")
m_attach_root=$(gettext "               Attach Path: %s")
m_attach_ds=$(gettext   "        Attach ZFS Dataset: %s")
m_gzinc=$(gettext       "       Global zone version: %s")
m_zinc=$(gettext        "   Non-Global zone version: %s")
m_need_update=$(gettext "                Evaluation: Packages in zone %s are out of sync with the global zone. To proceed, retry with the -u flag.")
m_cache=$(gettext       "                     Cache: Using %s.")
m_publisher=$(gettext   "  Updating non-global zone: Propagating publisher %s.")
m_image_link=$(gettext  "  Updating non-global zone: Linking to image %s.")
m_sync_done=$(gettext   "  Updating non-global zone: Zone updated.")
m_complete=$(gettext    "                    Result: Attach Succeeded.")
m_failed=$(gettext      "                    Result: Attach Failed.")

#
# These two messages are used by the install_image function in
# /usr/lib/brand/shared/common.ksh.  Yes, this is terrible.
#
installing=$(gettext    "                Installing: This may take several minutes...")
no_installing=$(gettext "                Installing: Using pre-existing data in zonepath")

f_sanity_variant=$(gettext "  Sanity Check: FAILED, couldn't determine %s from image.")
f_sanity_global=$(gettext  "  Sanity Check: FAILED, appears to be a global zone (%s=%s).")
f_update=$(gettext "Could not update attaching zone")
f_ds_config=$(gettext  "Failed to configure dataset %s: could not set %s.")
f_no_active_ds_mounted=$(gettext  "Failed to locate any dataset mounted at %s.  Attach requires a mounted dataset.")
f_nonsticky=$(gettext "Could not set legacy publisher to non-sticky")
e_dataset_disappeared=$(gettext "Dataset %s was unexpectedly unmounted")
e_dataset_not_mounted=$(gettext "Dataset %s exists in boot environment but not mounted")
e_dataset_not_in_be=$(gettext "Dataset %s mountpoint %s is not under zone root %s")

# Clean up on interrupt
trap_cleanup() {
	typeset msg=$(gettext "Installation cancelled due to interrupt.")
	trap - INT

	log "$msg"

	# umount any mounted file systems
	umnt_fs

	trap_exit
}

# If the attach failed then clean up the ZFS datasets we created.
trap_exit() {
	trap - INT
	if [[ -n $EXIT_NOEXECUTE ]]; then
		# dryrun mode, nothing to do here; exit with whatever
		# EXIT_CODE is set to.
		;
	elif [[ $EXIT_CODE == $ZONE_SUBPROC_USAGE ]]; then
		# Usage message printed, nothing to do here.
		;
	elif [[ $EXIT_CODE == $ZONE_SUBPROC_OK ]]; then
		# unmount the zoneroot if labeled brand
		is_brand_labeled
		(( $? == 1 )) && ( umount $ZONEROOT || \
		    log "$f_zfs_unmount" "$ZONEPATH/root" )
	else
		if [[ "$install_media" != "-" ]]; then
			/usr/lib/brand/ipkg/uninstall $ZONENAME $ZONEPATH -F
		else
			# Restore the zone properties for the pre-existing
			# dataset.
			if [[ -n "$ACTIVE_DS" ]]; then
				zfs set canmount=off $ACTIVE_DS
				(( $? != 0 )) && error "$f_ds_config" \
				    "$ACTIVE_DS" "canmount=on"
				zfs set zoned=off $ACTIVE_DS
				(( $? != 0 )) && error "$f_ds_config" \
				    "$ACTIVE_DS" "zoned=off"
				zfs set mountpoint=$ZONEROOT $ACTIVE_DS
				(( $? != 0 )) && error "$f_ds_config" \
				    "$ACTIVE_DS" "mountpoint=$ZONEROOT"
				zfs set canmount=on $ACTIVE_DS
				(( $? != 0 )) && error "$f_ds_config" \
				    "$ACTIVE_DS" "canmount=on"
				zfs mount "$ACTIVE_DS" || \
				    error "$e_mount1_failed" "$ACTIVE_DS"
			fi
		fi
		log "$m_failed"
	fi

	exit $EXIT_CODE
}

EXIT_CODE=$ZONE_SUBPROC_USAGE
install_media="-"

trap trap_cleanup INT
trap trap_exit EXIT

PKG=pkg
KEYDIR=/var/pkg/ssl

# If we weren't passed at least two arguments, exit now.
(( $# < 2 )) && exit $ZONE_SUBPROC_USAGE

zone=
init_zone zone "$1" "$2"
# Set ZONEPATH, etc.
eval $(bind_legacy_zone_globals zone)

shift; shift	# remove ZONENAME and ZONEPATH from arguments array

logdir="$ZONEROOT/var/log"

#
# Resetting GZ_IMAGE to something besides slash allows for simplified
# debugging of various global zone image configurations-- simply make
# an image somewhere with the appropriate interesting parameters.
#
GZ_IMAGE=${GZ_IMAGE:-/}
PKG_IMAGE=$GZ_IMAGE
export PKG_IMAGE

allow_update=0
noexecute=0

unset inst_type
unset sc_config

# Get publisher information for global zone.  These structures are used
# to store information about the global zone publishers and
# incorporations.

typeset gz_incorporations=""

#
verbose=""
# Other brand attach options are invalid for this brand.
while getopts "a:c:d:n:r:uv" opt; do
	case $opt in
		a)
			if [[ -n "$inst_type" ]]; then
				fatal "$incompat_options" "$m_usage"
			fi
			[[ -f $OPTARG ]] || fatal "$f_arg_not_file" "$OPTARG"
		 	inst_type="archive"
			install_media="$OPTARG"
			;;
		c)	sc_config="$OPTARG" ;;
		d)
			if [[ -n "$inst_type" ]]; then
				fatal "$incompat_options" "$m_usage"
			fi
			[[ -d $OPTARG ]] || fatal "$f_arg_not_dir" "$OPTARG"
		 	inst_type="directory"
			install_media="$OPTARG"
			;;
		n)	noexecute=1
	       		EXIT_NOEXECUTE=1
			dryrun_mfst=$"OPTARG"
			;;
		r)
			if [[ -n "$inst_type" ]]; then
				fatal "$incompat_options" "$m_usage"
			fi
			[[ -f $OPTARG ]] || fatal "$f_arg_not_file" "$OPTARG"
		 	inst_type="stdin"
			install_media="$OPTARG"
			;;
		u)	allow_update=1 ;;
		v)	verbose="-v"
			OPT_V=1 ;;	# used for vlog()
		?)	fail_usage "" ;;
		*)	fail_usage "";;
	esac
done
shift $((OPTIND-1))

if [[ $noexecute == 1 && -n "$inst_type" ]]; then
	fatal "$m_usage"
fi

[[ -z "$inst_type" ]] && inst_type="directory"

if [ $noexecute -eq 1 ]; then
	#
	# the zone doesn't have to exist when the -n option is used, so do
	# this work early.
	#

	# LIXXX There is no sw validation for IPS right now, so just pretend
	# everything will be ok.

	# Set exit code for the trap handler.
	EXIT_CODE=$ZONE_SUBPROC_OK
	exit $EXIT_CODE
fi

enable_zones_services
if [[ $? -ne 0 ]]; then
	exit $ZONE_SUBPROC_NOTCOMPLETE
fi

LOGFILE=$(/usr/bin/mktemp -t -p /var/tmp ${zone.name}.attach_log.XXXXXX)
if [[ -z "$LOGFILE" ]]; then
	fatal "$e_tmpfile"
fi
exec 2>>"$LOGFILE"
log "$m_attach_log" "$LOGFILE"

# Remember what was mounted on the zone root in case the attach fails.
get_ds_from_path "${zone.root}" ACTIVE_DS
attach_datasets -t "$inst_type" -m "$install_media" zone
migrate_export zone

#
# Perform a sanity check to confirm that the image is not a global zone.
#
VARIANT=variant.opensolaris.zone
variant=$(LC_ALL=C $PKG -R $ZONEROOT variant -H $VARIANT)
[[ $? -ne 0 ]] && fatal "$f_sanity_variant" $VARIANT

echo $variant | IFS=" " read variantname variantval
[[ $? -ne 0 ]] && fatal "$f_sanity_variant"

# Check that we got the output we expect...
[[ $variantname = "$VARIANT" ]] || fatal "$f_sanity_variant" $VARIANT

# Check that the variant is non-global, else fail
[[ $variantval = "nonglobal" ]] || fatal "$f_sanity_global" $VARIANT $variantval


#
# We're done with the global zone: switch images to the non-global
# zone.
#
PKG_IMAGE="$ZONEROOT"

#
# If there is a cache, use it.
#
if [[ -f /var/pkg/pkg5.image && -d /var/pkg/publisher ]]; then
	# respect PKG_CACHEROOT if the caller has it set.
	[ -z "$PKG_CACHEROOT" ] && PKG_CACHEROOT=/var/pkg/publisher
	export PKG_CACHEROOT
	log "$m_cache" "$PKG_CACHEROOT"
fi

#
# pkg update-format doesn't allow a dry run or provide any other way to
# see if an update is needed.
#
log "$v_update_format"
if [[ $allow_update == 1 ]]; then
	$PKG update-format || pkg_err_check "$e_update_format"
fi

#
# Set the use-system-repo property.
#
LC_ALL=C $PKG set-property use-system-repo true
if [[ $? != 0 ]]; then
    log "\n$f_set_sysrepo_prop_fail"
    EXIT_CODE=$ZONE_SUBPROC_NOTCOMPLETE
    exit $EXIT_CODE
fi

LC_ALL=C $PKG refresh --full

#
# Reset the pkg image back to the global zone so that we link the
# zoneroot to that image.
#
PKG_IMAGE=$GZ_IMAGE

pkg_args=""
if [[ $allow_update == 0 ]]; then
	pkg_args="$pkg_args --no-pkg-updates"
fi

#
# Look for the 'entire' incorporation.  We check for this because if the
# user has removed it then we'll want to remove it from the zone during
# attach.  The reason is that we're unlikely to be able to attach a
# highly constrained zone (ie, one that has entire) to a loosely
# constrainted global zone (ie, one that doesn't have entire installed).
#
entire_fmri=$(get_entire_incorp)
if [[ $allow_update != 0 && -z $entire_fmri ]]; then
	pkg_args="$pkg_args --reject pkg:///entire"
fi

log "$m_image_link" $GZ_IMAGE
LC_ALL=C $PKG attach-linked $verbose -f --allow-relink --accept \
    $pkg_args \
    -c zone:${zone.name} $ZONEROOT || pkg_err_check "$f_update"

[[ -n $sc_config ]] && reconfigure_zone $sc_config

log "\n$m_sync_done"
log "$m_complete"

EXIT_CODE=$ZONE_SUBPROC_OK
exit $ZONE_SUBPROC_OK
