.. CDDL HEADER START

.. The contents of this file are subject to the terms of the
   Common Development and Distribution License (the "License").
   You may not use this file except in compliance with the License.

.. You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
   or http://www.opensolaris.org/os/licensing.
   See the License for the specific language governing permissions
   and limitations under the License.

.. When distributing Covered Code, include this CDDL HEADER in each
   file and include the License file at usr/src/OPENSOLARIS.LICENSE.
   If applicable, add the following below this CDDL HEADER, with the
   fields enclosed by brackets "[]" replaced with your own identifying
   information: Portions Copyright [yyyy] [name of copyright owner]

.. CDDL HEADER END

.. Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.

Chapter 4
---------

Packaging Software with IPS
...........................

This chapter describes how to package your software with IPS.  

Packaging software with IPS is often relatively straightforward due to 
amount of automation that is provided; the goal has been as much
as possible to avoid repetitive tedium since that seems to be the
principle cause of most packaging bugs.

Publication in IPS consists of the following steps:

* generate a package manifest
* add necessary metadata to to the generated manifest
* evaluate dependencies
* add any facets or actuators that are needed
* check the package with pkglint
* publish the package
* test the package

We'll walk through these steps in the following sections.

Generate a package manifest
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The easiest way to get started is to lay out the software in the
fashion you wish it installed in a directory.

This can be done with install target in Makefiles, or if the software
you wish to package is already in a tarball, unpacking the tarball
into a subdirectory.  For many open source software packages that use
autoconf(1), setting the DESTDIR environment variable to point to the
desired prototype area will accomplish this.

Suppose your software consists of a binary, a library and a man page,
and you wish to install this software in a directory under /opt named
``mysoftware``.  You should create a directory (named ``proto`` in the
examples) in your build area under which your software appears; e.g::

   proto/opt/mysoftware/lib/mylib.so.1 
   proto/opt/mysoftware/bin/mycmd
   proto/opt/mysoftware/man/man1/mycmd.1

Now, let's generate a manifest for this proto area.  We'll pipe it
through pkgfmt to format the manifest more nicely for humans. Assuming
that the proto directory is in the current working directory::

  $ pkgsend generate proto | pkgfmt > mypkg.p5m.1

.. raw:: pdf

    PageBreak

Examining the file, you'll see it contains the following lines::

  dir path=opt group=bin mode=0755 owner=root
  dir path=opt/mysoftware group=bin mode=0755 owner=root
  dir path=opt/mysoftware/bin group=bin mode=0755 owner=root
  dir path=opt/mysoftware/lib group=bin mode=0755 owner=root
  dir path=opt/mysoftware/man group=bin mode=0755 owner=root
  dir path=opt/mysoftware/man/man1 group=bin mode=0755 owner=root
  file opt/mysoftware/bin/mycmd path=opt/mysoftware/bin/mycmd group=bin \
      mode=0755 owner=root
  file opt/mysoftware/lib/mylib.so.1 path=opt/mysoftware/lib/mylib.so.1 \
      group=bin mode=0644 owner=root
  file opt/mysoftware/man/man1/mycmd.1 path=opt/mysoftware/man/man1/mycmd.1 \
      group=bin mode=0644 owner=root

You'll notice that path of the files to be packages appears
twice - once in the *path=...* attribute, and once as the positional
second attribute.  The latter describes the path in the proto area,
the former the location the file is to be installed.  This double
entry allows one to modify the installation location without requiring
the proto area to be modified to match; this can save significant
amounts of effort when repackaging open source software when
the install locations are defined for another operating system.

Also, note that pkgsend generate has picked defaults for directory
owners and groups.  In the case of /opt, the defaults are not correct;
we'll just delete that directory since it's delivered by other packages
already on the system.

Add necessary metadata to to the generated manifest
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We also need to define several important pieces of metadata, expressed
as set actions, that should appear in every package:

* ``pkg.fmri`` defines the name and version of the package as described
  in *Chapter 3*.  Discussion about version numbering can be seen
  in *Chapter 5* (XXX huh, not sure what was intended there?) and a
  description of Solaris versioning can found in *Chapter 13* (XXX that needs
  content)

* ``pkg.description`` is a proper description of the contents of the
  package.

* ``pkg.summary`` is a one-line synopsis of the description.

* ``variant.arch`` enumerates the architectures for which this package
  is suitable.  If the entire package can be installed on any 
  architecture, this may be omitted.  Producing packages that have
  different components for different architectures is discussed in
  *Chapter 7*.

* ``info.classification`` is a grouping scheme used by the packagemanager,
  the IPS GUI, discussed in the previous chapter.  The supported values
  are shown in *Appendix 1*.  In this case, we pick an arbitrary one
  for our sample package.  Failure to include this will mean the
  PackageManager doesn't display the package; this is handy for common
  infrastructure packages which may not be of direct interest, but
  instead are depended upon by higher level packages.

In addition, we will add a link action to /usr/share/man/index.d pointing to
our man directory, and will discuss this link when covering *facets* and
*actuators* later in this chapter.

Rather than modifying the generated manifest directly, we'll use
pkgmogrify to edit the generated manifest.  A full description
of how pkgmogrify can be used to modify package manifests may be
found in *Chapter 8*.

In this example we use the macro capability to define the architecture,
as well as regular expression matching for the directory we want to elide
from the manifest.

.. raw:: pdf

    PageBreak

Now we create a small file containing the information we wish to
add to the manifest, as well as the transform needed to drop the opt
directory from the manifest::

    set name=pkg.fmri value=mypkg@1.0,5.11-0
    set name=pkg.summary value="This is our example package"
    set name=pkg.description value="This is a full description of \
    all the interesting attributes of this example package." 
    set name=variant.arch value=$(ARCH)
    set name=info.classification \
        value=org.opensolaris.category.2008:Applications/Accessories
    link path=usr/share/man/index.d/mysoftware target=opt/mysoftware/man
    <transform dir path=opt$->drop>

Running pkgmogrify over mypkg.p5m.1 with the above lines in
a file named mypkg.mog::

    $ pkgmogrify -DARCH=`uname -p` mypkg.p5m.1 mypkg.mog  | pkgfmt > mypkg.p5m.2

Examining the file we see::

    set name=pkg.fmri value=mypkg@1.0,5.11-0
    set name=pkg.description \
        value="This is a full description of all the interesting attributes of this example package. "
    set name=pkg.summary value="This is our example package"
    set name=info.classification \
        value=org.opensolaris.category.2008:Applications/Accessories
    set name=variant.arch value=i386
    link path=usr/share/man/index.d/mysoftware target=opt/mysoftware/man
    dir path=opt/mysoftware group=bin mode=0755 owner=root
    dir path=opt/mysoftware/bin group=bin mode=0755 owner=root
    dir path=opt/mysoftware/lib group=bin mode=0755 owner=root
    dir path=opt/mysoftware/man group=bin mode=0755 owner=root
    dir path=opt/mysoftware/man/man1 group=bin mode=0755 owner=root
    file opt/mysoftware/bin/mycmd path=opt/mysoftware/bin/mycmd group=bin \
        mode=0755 owner=root
    file opt/mysoftware/lib/mylib.so.1 path=opt/mysoftware/lib/mylib.so.1 \
        group=bin mode=0644 owner=root
    file opt/mysoftware/man/man1/mycmd.1 path=opt/mysoftware/man/man1/mycmd.1 \
        group=bin mode=0644 owner=root
    link path=usr/share/man/index.d/mysoftware target=../../../../opt/mysoftware/man

Note that the directory action defining "opt" has been removed, and the
manifest contents from mypkg.mog have been added to our package.
For now, pkgfmt doesn't add line breaks to strings; this may
change.


Evaluate dependencies
~~~~~~~~~~~~~~~~~~~~~

IPS allows automatic generation of package dependencies using the ``pkgdepend``
command.  The *depend* actions that are generated are discussed in *Chapter 3*
and *Chapter 6*.

Dependency generation is composed of two separate steps:

  * determining the files on which our software depends
  * determining the packages that contain those files

These steps are referred to as *dependency generation* and
*dependency resolution* and performed using the ``generate`` and ``resolve``
subcommands of pkgdepend, respectively.

First, we'll generate our dependencies::

    $ pkgdepend generate -md proto mypkg.p5m.2 | pkgfmt > mypkg.p5m.3

In this new file, we see::

    set name=pkg.fmri value=mypkg@1.0,5.11-0
    set name=pkg.description \
        value="This is a full description of all the interesting attributes of this example package."
    set name=pkg.summary value="This is our example package"
    set name=info.classification \
        value=org.opensolaris.category.2008:Applications/Accessories
    set name=variant.arch value=i386
    dir path=opt/mysoftware group=bin mode=0755 owner=root
    dir path=opt/mysoftware/bin group=bin mode=0755 owner=root
    dir path=opt/mysoftware/lib group=bin mode=0755 owner=root
    dir path=opt/mysoftware/man group=bin mode=0755 owner=root
    dir path=opt/mysoftware/man/man1 group=bin mode=0755 owner=root
    file opt/mysoftware/bin/mycmd path=opt/mysoftware/bin/mycmd group=bin \
        mode=0755 owner=root
    file opt/mysoftware/lib/mylib.so.1 path=opt/mysoftware/lib/mylib.so.1 \
        group=bin mode=0644 owner=root
    file opt/mysoftware/man/man1/mycmd.1 path=opt/mysoftware/man/man1/mycmd.1 \
        group=bin mode=0644 owner=root
    link path=usr/share/man/index.d/mysoftware target=../../../../opt/mysoftware/man
    depend fmri=__TBD pkg.debug.depend.file=libc.so.1 \
        pkg.debug.depend.reason=opt/mysoftware/bin/mycmd \
        pkg.debug.depend.type=elf type=require pkg.debug.depend.path=lib \
        pkg.debug.depend.path=opt/mysoftware/lib pkg.debug.depend.path=usr/lib
    depend fmri=__TBD pkg.debug.depend.file=libc.so.1 \
        pkg.debug.depend.reason=opt/mysoftware/lib/mylib.so.1 \
        pkg.debug.depend.type=elf type=require pkg.debug.depend.path=lib \
        pkg.debug.depend.path=usr/lib

pkgdepend has added notations about a dependency on ``libc.so.1`` by both
``mylib.so.1`` and ``mycmd``.  Note that the internal dependency between
``mycmd`` and ``mylib.so.1`` is currently silently elided by pkgdepend.

Now we need to resolve these dependencies.  This resolution phase is
done by examining the packages currently installed on the machine used
for building the software.  Once again, pkgdepend does this, but this
time, by default, puts its output in mypkg.p5m.3.res.  Note that this
takes a while to run as it loads lots of information about the system on
which it is running.  pkgdepend will resolve many packages at once if
you wish to amortize this time over all packages; running it on one
package at a time is not time efficient.

::

    $ pkgdepend resolve -m mypkg.p5m.3


After a while, we find in mypkg.p5m.3.res::

    set name=pkg.fmri value=mypkg@1.0,5.11-0
    set name=pkg.description \
        value="This is a full description of all the interesting attributes of this example package."
    set name=pkg.summary value="This is our example package"
    set name=info.classification \
        value=org.opensolaris.category.2008:Applications/Accessories
    set name=variant.arch value=i386
    dir path=opt/mysoftware group=bin mode=0755 owner=root
    dir path=opt/mysoftware/bin group=bin mode=0755 owner=root
    dir path=opt/mysoftware/lib group=bin mode=0755 owner=root
    dir path=opt/mysoftware/man group=bin mode=0755 owner=root
    dir path=opt/mysoftware/man/man1 group=bin mode=0755 owner=root
    file opt/mysoftware/bin/mycmd path=opt/mysoftware/bin/mycmd group=bin \
        mode=0755 owner=root
    file opt/mysoftware/lib/mylib.so.1 path=opt/mysoftware/lib/mylib.so.1 \
        group=bin mode=0644 owner=root
    file opt/mysoftware/man/man1/mycmd.1 path=opt/mysoftware/man/man1/mycmd.1 \
        group=bin mode=0644 owner=root
    link path=usr/share/man/index.d/mysoftware target=opt/mysoftware/man
    depend fmri=pkg:/system/library@0.5.11-0.168 type=require


Add any facets or actuators that are needed
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Facets and actuators are discussed in more detail in *Chapter 7* and
*Chapter 9*, but briefly, facets allow us to denote actions in a package that
are optionally installed, and actuators allow us to specify side effects that
must be triggered when an action in our package is installed, updated, or
removed.

Since we are delivering a man page in ``opt/mysoftware/man/man1`` we would
like to add a facet to indicate that documentation is optional.

We would also like an SMF service, ``svc:/application/man-index:default`` to be
restarted when our package is installed, so that our man page is included in the
index.

The ``man-index`` service looks in ``/usr/share/man/index.d`` for symbolic
links to directories containing man pages, adding the target of each link to
the list of directories it scans, hence our earlier addition of that link to
our man pages.  This is good example of the *self assembly* idiom that was
discussed in *Chapter 1*, and is used throughout the packaging of Solaris
itself.

Solaris ships with a set of pkgmogrify transforms that were used to package
the the operating system, in ``/usr/share/pkg/transforms``.  These transforms
are discussed in more detail in *Chapter 8*.

The ``documentation`` transform there is closest to what we need here, though
since we're delivering our man page to ``/opt``, we'll use the ``documentation``
transform as a guide, and use the following transform instead::

    <transform dir file link hardlink path=opt/.+/man(/.+)? -> \
        default facet.doc.man true>

    <transform file path=opt/.+/man(/.+)? -> \
        add restart_fmri svc:/application/man-index:default>

We can run our manifest through this transform using::

    $ pkgmogrify mypkg.p5m.3.res /tmp/doc-transform | pkgfmt > mypkg.p5m.4.res

which changes the three man-page-related actions in our manifest, from::

    dir path=opt/mysoftware/man group=bin mode=0755 owner=root
    dir path=opt/mysoftware/man/man1 group=bin mode=0755 owner=root
    file opt/mysoftware/man/man1/mycmd.1 path=opt/mysoftware/man/man1/mycmd.1 \
        group=bin mode=0644 owner=root

to::

    dir  path=opt/mysoftware/man owner=root group=bin mode=0755 facet.doc.man=true
    dir  path=opt/mysoftware/man/man1 owner=root group=bin mode=0755 \
        facet.doc.man=true
    file opt/mysoftware/man/man1/mycmd.1 path=opt/mysoftware/man/man1/mycmd.1 \
        owner=root group=bin mode=0644 \
        restart_fmri=svc:/application/man-index:default facet.doc.man=true

For efficiency, we could have included this transform when originally adding
metadata to our package, before running pkgdepend.


Check the package with pkglint
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The last thing we need to do before publication, is to run pkglint over our
manifest.  This helps us determine if we've made any errors while writing the
the manifest that we'd like to catch before publication.  Some of the errors
that pkglint can catch are ones also caught either at publication time, or
when a user tries to install a package, but obviously, we'd like to catch
errors as early as possible in the package authoring process.

There are two modes in which to run pkglint:

  * directly on the manifest itself
  * on the manifest, also referencing a repository

For developers looking to quickly check the validity of their manifests, using
the first form is often sufficient.  The second form is recommended to be run at
*least once* before publication to a repository.

By referencing a repository, pkglint can perform additional checks to ensure
that if the package will *play well* with other packages in that repository.

For example, pkglint will check that the package doesn't
deliver files already owned by another package, and that all metadata for
shared, reference-counted actions (such as directories) is consistent across
packages.

The full list of checks that pkglint performs can be shown with ``pkglint -L``
and detailed information on how to enable, disable and bypass particular checks
is given in the pkglint man page.  It also details how to extend pkglint to
run additional checks.

In the case of our test package, we see::

    $ pkglint mypkg.p5m.4.res
    Lint engine setup...
    Starting lint run...
    WARNING opensolaris.manifest001.1 Missing attribute
        'org.opensolaris.consolidation' in pkg:/mypkg@1.0,5.11-0
    WARNING pkglint.action005.1       obsolete dependency check skipped: unable
        to find dependency pkg:/system/library@0.5.11-0.168 for
        pkg:/mypkg@1.0,5.11-0

These warnings are acceptable for our purposes:

  * ``opensolaris.manifest001.1`` is warning us that we haven't declared a tag
    that is generally only required for bundled Solaris software, so we can
    ignore this warning.

  * ``pkglint.action005.1`` is warning us that pkglint wasn't able to find a
    package called ``pkg:/system/library@0.5.11-0.168`` which we have generated
    a dependency on.  Since pkglint was called with just the manifest file as
    an argument, it does not know which repository that package is present in,
    hence the warning.  If we were to run pkglint with a ``-r`` flag referencing
    a repository containing that package, this warning would not be shown.


Publish the package
~~~~~~~~~~~~~~~~~~~

Now that our package is created, dependencies are added, and it has been checked
checked for correctness, we can publish the package.

IPS provides three different ways to deliver a package:

  * publish to a local file-based repository
  * publish to a remote http-based repository
  * convert to a .p5p package archive

Generally, publishing to a file-based repository is sufficient while testing
a package.

If the package needs to be transferred to other machines, converting one or
more packages to a p5p archive make that convenient.

XXX how's the wording on the paragraph below?

The package can also be published directly to a http repository, when using
on a machine with a read/write instance of ``svc:/application/pkg/server``
(which in turn runs ``pkg.depotd``).  We do not generally recommend this method
since there are no authorization/authentication checks when publishing over
http, though it can be convenient on secure networks.

Local file repositories
```````````````````````

The ``pkgrepo`` command can be used to create a local file repository.  We will
choose a location on our system, create a repository, then set the default
publisher for that repository::

    $ pkgrepo create-repository /scratch/my-repository
    $ pkgrepo create /scratch/my-repository
    $ pkgrepo -s /scratch/my\-repository set publisher/prefix=mypublisher
    $ find /scratch/my\-repository/
    /scratch/my-repository/
    /scratch/my-repository/pkg5.repository

We can now use ``pkgsend`` to publish our package, and ``pkgrepo`` to examine
the repository afterwards::

    $ pkgsend -s /scratch/my-repository/ publish -d proto mypkg.p5m.4.res
    pkg://mypublisher/mypkg@1.0,5.11-0:20111012T034303Z
    PUBLISHED
    $ pkgrepo -s /scratch/my-repository info
    PUBLISHER   PACKAGES STATUS           UPDATED
    mypublisher 1        online           2011-10-12T03:43:04.117536Z


Package archives
````````````````

Package archives, are convenient ways to move groups of packages around.
We can use the ``pkgrecv`` command to create package archives from package
repositories, and visa versa.

In the case of our simple file repository above, we can create an archive
from this repository with the following command::

    $ pkgrecv -s /scratch/my\-repository -a -d myarchive.p5p mypkg
    Retrieving packages for publisher mypublisher ...
    Retrieving and evaluating 1 package(s)...
    DOWNLOAD                                  PKGS       FILES    XFER (MB)
    Completed                                  1/1         3/3      0.7/0.7
    
    
    ARCHIVE                                             FILES   STORE (MB)
    myarchive.p5p                                       14/14      0.7/0.7

We can list the newest available packages from a repository using pkgrecv::

   $ pkgrecv -s /scratch/my\-repository --newest
   pkg://mypublisher/mypkg@1.0,5.11-0:20111012T033207Z

This output can be useful when constructing scripts to create archives with
the latest versions of all packages from a given repository.

Solaris is limited in its use of package archives at present, in that they
cannot be used in the global zone for systems that have non-global zones
configured.

Temporary publishers set with the ``-g`` flag for ``pkg install`` cannot be used
on systems with child or parent images (non-global zones have a child/parent
relationship with the global zone) and the
``svc:/application/pkg/system-repository:default`` service cannot read package
archives at present.

Package archives can be set as sources of local publishers in non-global zones,
however.

Test the package
~~~~~~~~~~~~~~~~

Having published our package, we are interested in seeing if it has been
packaged properly.

In this example, we will ensure that our user has the *Software Installation*
Profile, then we will add the publisher in our repository to the system and
proceed to install the package::

    $ sudo su
    Password:
    # usermod -P 'Software Installation' myuser
    Found user in files repository.
    UX: usermod: myuser is currently logged in, some changes may not take effect
    until next login.
    ^D

::

    $ pfexec pkg set-publisher -p /scratch/my\-repository
    pkg set-publisher:
      Added publisher(s): mypublisher

    $ pfexec pkg install mypkg
               Packages to install:  1
           Create boot environment: No
    Create backup boot environment: No

    DOWNLOAD                                  PKGS       FILES    XFER (MB)
    Completed                                  1/1         3/3      0.7/0.7

    PHASE                                        ACTIONS
    Install Phase                                  15/15

    PHASE                                          ITEMS
    Package State Update Phase                       1/1
    Image State Update Phase                         2/2

    PHASE                                          ITEMS
    Reading Existing Index                           8/8
    Indexing Packages                                1/1

.. raw:: pdf

    PageBreak

We can then examine the software as it was delivered on the system::

    $ find /opt/mysoftware/
    /opt/mysoftware/
    /opt/mysoftware/bin
    /opt/mysoftware/bin/mycmd
    /opt/mysoftware/lib
    /opt/mysoftware/lib/mylib.so.1
    /opt/mysoftware/man
    /opt/mysoftware/man/man-index
    /opt/mysoftware/man/man-index/term.doc
    /opt/mysoftware/man/man-index/.index-cache
    /opt/mysoftware/man/man-index/term.dic
    /opt/mysoftware/man/man-index/term.req
    /opt/mysoftware/man/man-index/term.pos
    /opt/mysoftware/man/man1
    /opt/mysoftware/man/man1/mycmd.1

Along with our binaries and man page being installed, the system has also
generated the man page indexes as a result of our actuator restarting the
``man-index`` service.

We can see that ``pkg info`` shows the metadata that we added to our package::

    $ pkg info mypkg
              Name: mypkg
           Summary: This is our example package
       Description: This is a full description of all the interesting attributes of
                    this example package.
          Category: Applications/Accessories
             State: Installed
         Publisher: mypublisher
           Version: 1.0
     Build Release: 5.11
            Branch: 0
    Packaging Date: October 12, 2011 03:43:03 AM
              Size: 1.75 MB
              FMRI: pkg://mypublisher/mypkg@1.0,5.11-0:20111012T034303Z

We can also see that ``pkg search`` will return hits when querying for files in
our package::

    $ pkg search -l mycmd.1
    INDEX      ACTION VALUE                           PACKAGE
    basename   file   opt/mysoftware/man/man1/mycmd.1 pkg:/mypkg@1.0-0


