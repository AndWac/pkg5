		Chapter 11 - signing packages.


One important consideration in the design of IPS was being able to
validate that the software installed on the customer's machine was
actually as originally specified by the publisher.  This ability to
validate the installed system is key for both the customer and the
support engineering staff.

To support this validation, manifests can be signed in IPS with the
signatures becoming part of the manifest.  Signatures are represented
as actions like all other manifest content.  Since manifests contain
all the package metadata - file permissions, ownership, content
hashes, etc, a signature action that validates that the manifest has
not be altered since it was published is an important part of system
validation, and insures that the package has not be altered.

The signature actions form a Merkle, or hash, tree that includes the
delivered binaries such that complete verification of the installed
software is possible.  There are other uses for manifest signing
beyond validation; signatures can also be used to indicate approval by
other organizations or parties.  For example, the internal QA
organization could sign manifests of Solaris packages once they had be
determined to be qualified for production use; policy settings could
mandate such approvals prior to installation.

As a result, a useful characteristic for signatures is to be
independent of other signatures in a manifest; it was decided
necessary to support the addition (or removal) of signatures (but not
other actions) in a manifest without invalidating the other signatures
that might be present.  This feature also facilitates production
handoffs, with signatures used along the path to indicate completion
along the way; subsequent steps can optionally remove previous
signatures at any time without ill-effect.

Signature actions look like this:

signature <hash of certificate> algorithm=<signature algorithm> \
    value=<signature value> \ chain="<hashes of certs needed to
    validate primary certificate>" \ version=<pkg version of
    signature>

The payload and pkg.chain_certs attributes represent the packaging
hash of the pem file(s) containing the x.509 certificate(s)
downloadable from the originating repository; the value is the signed
hash of the manifest's message text, prepared as discussed below.  The
payload certificate is the certificate which verifies the value in
pkg.sigval.  The other certificates presented need to form a
certificate path that leads from the payload certificate to the trust
anchor(s) that was established as part of the publisher configuration.

Two types of signature algorithms are currently supported.  The first
is the rsa group of signature algorithms; an example is "rsa-sha256".
The bit after the dash specifies the hash algorithm to use to change
the message text into a single value the rsa algorithm can use.

The second type of signature algorithm is compute the hash only. This
type of algorithm exists primarily for testing and process
verification purposes and presents the hash as the signature value.  A
signature action of this type is indicated by the lack of a payload
certificate hash.  This type of signature action is verified if the
image is configured to check signatures.  Its presence however does
not count as a signature if signatures are required.

signature algorithm=<hash algorithm> value=<hash> \ version=<pkg
    version of signature>

Additional signature types (pgp, for example) may be added in the
future.

Additional metadata can be added to a signature if desired, as with
any other action; such metadata is protected by that signature.

Policies may be set for the image or for specific publishers.  The
policies include ignoring signatures, verifying existing signatures,
requiring signatures, and requiring that specific common names must be
seen in the chain of trust.  Other policies may be added in the
future.

Publishing a signed manifest is a two step process.  First, the
package is published unsigned, to a repository.  The package is then
updated in place, using pkgsign, appending a signature action to the
manifest in the repository but leaving the package, including its
timestamp, intact.  This process allows a signature action to be added
by someone other than the publisher without invalidating the original
publisher's signature.  For example, the QA department of a company
may want to sign all packages that are installed internally to
indicate they have been approved for use, but not republish the
packages which would create a new timestamp and invalidate the
signature of the original publisher.

Note that pkgsign is the only way to publish a signed package.  If one
attempts to publish a package already containing a signature, that
signature is removed with a warning.  The pkgsign man page contains
examples of how to use pkgsign.


