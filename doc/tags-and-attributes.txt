
pkg
TAGS AND ATTRIBUTES

1.  Definitions

    Tags are the settings that affect individual files within a package.
    Tags may eventually have values, depending on how many tags are
    required to handle the SPARC-based platform binaries.

    Attributes:  settings that apply to an entire package.  Introduction
    of an attribute that causes different deliveries by the client could
    cause a conflict with the versioning algebra, so we attempt to avoid
    them.

2.  Tags

platform

ISA (particularly need to know i386 on i86pc vs amd64 on i86pc)

debug/non-debug

compatibility
	(for shipping non-bleeding edge .so.x.y.z copies, perhaps)


3.  Attributes

3.1.  Useful attributes

    Package aliases?

3.2.  Attributes best avoided

built-on release

    One problem we may run into is packages that have been built on a
    release newer than that on the image.  These packages should be
    evaluated as unsuitable for the image, and not offered in the graph.
    There are a few ways to handle this case:

    1.  Separate repository.  All packages offered by a repository were
	built on a known system configuration.  This change requires
	negotiation between client and server for a built-on match
	condition.  It also means that multiple repositories are needed
	for a long lifecycle distribution.

    2.  Attributes.  Each package comes with a built-on attribute.  This
	means that clients move from one built-on release to another
	triggered by conditions set by the base package on the client.
	Another drawback is that it becomes impossible to request a
	specific package by an FMRI, without additional knowledge.

    3.  Additional version specifier.  We could extend
	release,branch:timestamp to release,built,branch:timestamp--or
	fold the built and branch version together.  Since the built
	portion must reserve major.minor.micro, that means we move to a
	package FMRI that looks like

	coreutils@6.7,5.11.0.1:timestamp

	This choice looks awkward.  We could instead treat the built
	portion as having a default value on a particular client.  Then
	the common specifier would be

	name@release[,build]-branch:timestamp

        build would be the highest available valid release for the
	image.

    The meaning of the built-on version could be controversial.  A
    simple approach would be to base it on base/minimal's release,
    rather than uname(1) output.

