
pkg
IMAGES

:vim:set expandtab:

1.  Summary


2.  Discussion

2.1.  Image types

    Each collection of installed package instances is some kind of
    image.  We envision three kinds:

    - entire images
        An entire image contains (and can contain) all appropriate
        packages from a repository.  It has a machine type and release.

    - partial images
        A partial image contains (and can contain) all appropriate
        packages from a repository.  An partial image is tied to an
        entire image and has an identified list of non-writeable
        directory paths.  It inherits its machine type and release.

    - user images
        A user image consists entirely of relocatable packages.  It is
        tied to an entire image for dependency satisfaction of
        non-relocatable packages.  It inherits its machine type and
        release.

2.2.  Image configuration

2.2.1.  Configuration inheritance

    Some aspects of configuration can be shared between all images.  For
    instance, a user image may specify authorities beyond those encoded
    into the system defaults.  So, a user image must have authoritative
    configuration, but be able to draw on the parent image's state for
    default settings.

    Operations on partial images and non-live entire images may need to
    access image configuration data when smf(5) for that image is
    unavailable.  So images of these kinds must have cached
    configuration state.

    Roughly, these aspects are sufficient to constrain our configuration
    behaviour for user and entire images:

    [user image]
      look up local configuration
      if undefined, request properties from svc://application/pkg
      if unavailable, examine parent's configuration cache
      if undefined or unavailable, use hard-coded default

    [entire image]
      request properties from svc://application/pkg
      if unavailable, examine configuration cache
      if undefined or unavailable, use hard-coded default

    Partial images could have differing behaviour depending on whether
    the operation is invoked from within the partial image's "packaging
    context" (as it would be for an operation issued from within the
    zone), or outside it (operations on the entire image and its
    associated partial images).

    For the first case, the configuration strategy is the same as that
    for an entire image.  For the second case, we could do

    [partial image, external context]
      examine partial image configuration cache
      if unavailable, request properties from svc://application/pkg
      if undefined or unavailable, examine entire image configuration
        cache
      if undefined, use hard-coded default

    For certain properties (or even certain packages), it may be
    inappropriate to let the partial image configurations drift from
    that of the entire image.

2.2.2.  Configuration components

    List of authorities.  For each authority, we have a prefix, an
    origin URL, a list of mirror URLs, and annotations.

    authority_[escaped_name]/  Property group of type "com.sun.pkg,authority"
      /prefix                  pkg: authority
      /origin                  http:, https:, or ftp: URL
      /mirrors                 list of URLs

    Image attributes.  The image has a collection of simple attributes,
    like machine type.

    application/
      /preferred_auth          preferred authority for unknown package
                               lookups
      /[various]

    Entire images have a property group for each tied partial image.

    partial_[escaped_name]/    Property group of type "com.sun.pkg,partial"
      /path                     Filesystem path
      /vdomainname              Defined if this image is a virtual
                                domain controlled on this system.
      /vdomaintype              "xen", "zone", ...

    (XXX Should we instead assume that each of Zones and Xen will
    acquire service FMRIs per zone/domain?)
